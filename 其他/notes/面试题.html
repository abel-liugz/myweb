<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/JAVA.png"><link rel="stylesheet" href="/css/style.css"><title>Java常见面试题 | Abel's Web</title><meta name="description" content="My tech blog">
    <link rel="modulepreload" href="/assets/app.85e154b6.js"><link rel="modulepreload" href="/assets/面试题.html.5b19d14b.js"><link rel="modulepreload" href="/assets/面试题.html.6b713157.js"><link rel="prefetch" href="/assets/index.html.9cb6c8ab.js"><link rel="prefetch" href="/assets/IO流.html.43fd9aec.js"><link rel="prefetch" href="/assets/String.html.365ebe14.js"><link rel="prefetch" href="/assets/反射机制.html.b978aa38.js"><link rel="prefetch" href="/assets/基础知识.html.495db229.js"><link rel="prefetch" href="/assets/多线程.html.2ff7c74f.js"><link rel="prefetch" href="/assets/异常处理机制.html.4aaa1629.js"><link rel="prefetch" href="/assets/面向对象.html.4158d84e.js"><link rel="prefetch" href="/assets/MyBatis.html.2b3e32c2.js"><link rel="prefetch" href="/assets/Spring-AOP.html.64a30334.js"><link rel="prefetch" href="/assets/Spring-IOC.html.48e04bb0.js"><link rel="prefetch" href="/assets/Spring-Test.html.aa0c59fc.js"><link rel="prefetch" href="/assets/SpringBoot.html.ac30d93c.js"><link rel="prefetch" href="/assets/SpringMVC.html.45fdf8b5.js"><link rel="prefetch" href="/assets/SpringSecurity.html.8bc2fe83.js"><link rel="prefetch" href="/assets/基于MyBatis的分页查询.html.bc1d0178.js"><link rel="prefetch" href="/assets/HTTP.html.eb00fe7c.js"><link rel="prefetch" href="/assets/前端基础.html.91c4e0f5.js"><link rel="prefetch" href="/assets/docker.html.91edf7fc.js"><link rel="prefetch" href="/assets/各类工具、开发文档、常用下载.html.520bee64.js"><link rel="prefetch" href="/assets/Dubbo.html.71d41784.js"><link rel="prefetch" href="/assets/ELK.html.0c40efba.js"><link rel="prefetch" href="/assets/Nacos.html.829369a9.js"><link rel="prefetch" href="/assets/Quartz.html.267771fa.js"><link rel="prefetch" href="/assets/Seata.html.f7b8512a.js"><link rel="prefetch" href="/assets/Sentinel.html.9f07b786.js"><link rel="prefetch" href="/assets/SpringGateway网关.html.53f02975.js"><link rel="prefetch" href="/assets/微服务概念.html.1c3bb265.js"><link rel="prefetch" href="/assets/消息队列.html.c1512933.js"><link rel="prefetch" href="/assets/Redis.html.81712c7d.js"><link rel="prefetch" href="/assets/复杂SQL语句.html.6bc77d6f.js"><link rel="prefetch" href="/assets/数据库基础.html.9be17ec0.js"><link rel="prefetch" href="/assets/数据库进阶.html.9d78ac5a.js"><link rel="prefetch" href="/assets/数据结构.html.422d9cec.js"><link rel="prefetch" href="/assets/算法.html.eb3684dc.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.e8127865.js"><link rel="prefetch" href="/assets/IO流.html.eeae31cf.js"><link rel="prefetch" href="/assets/String.html.1bff0e61.js"><link rel="prefetch" href="/assets/反射机制.html.95d7a3fc.js"><link rel="prefetch" href="/assets/基础知识.html.7106bf6f.js"><link rel="prefetch" href="/assets/多线程.html.2d87978c.js"><link rel="prefetch" href="/assets/异常处理机制.html.d6e2dd1d.js"><link rel="prefetch" href="/assets/面向对象.html.edfc19b0.js"><link rel="prefetch" href="/assets/MyBatis.html.ebc5ee64.js"><link rel="prefetch" href="/assets/Spring-AOP.html.7aa5f4c5.js"><link rel="prefetch" href="/assets/Spring-IOC.html.9312688b.js"><link rel="prefetch" href="/assets/Spring-Test.html.9f6bcb98.js"><link rel="prefetch" href="/assets/SpringBoot.html.65c80b62.js"><link rel="prefetch" href="/assets/SpringMVC.html.c3f40a5f.js"><link rel="prefetch" href="/assets/SpringSecurity.html.752e51eb.js"><link rel="prefetch" href="/assets/基于MyBatis的分页查询.html.f1fe3c6c.js"><link rel="prefetch" href="/assets/HTTP.html.5201b9ad.js"><link rel="prefetch" href="/assets/前端基础.html.0dfea776.js"><link rel="prefetch" href="/assets/docker.html.087a759a.js"><link rel="prefetch" href="/assets/各类工具、开发文档、常用下载.html.6d1a4d38.js"><link rel="prefetch" href="/assets/Dubbo.html.7ca21492.js"><link rel="prefetch" href="/assets/ELK.html.d4a1e9c7.js"><link rel="prefetch" href="/assets/Nacos.html.67f33382.js"><link rel="prefetch" href="/assets/Quartz.html.b0fcc02a.js"><link rel="prefetch" href="/assets/Seata.html.8baef4a0.js"><link rel="prefetch" href="/assets/Sentinel.html.73d2dac5.js"><link rel="prefetch" href="/assets/SpringGateway网关.html.57ba2ab6.js"><link rel="prefetch" href="/assets/微服务概念.html.0ffe8fcf.js"><link rel="prefetch" href="/assets/消息队列.html.2397e23a.js"><link rel="prefetch" href="/assets/Redis.html.f6710bab.js"><link rel="prefetch" href="/assets/复杂SQL语句.html.7882af28.js"><link rel="prefetch" href="/assets/数据库基础.html.9a4f5914.js"><link rel="prefetch" href="/assets/数据库进阶.html.9912d06e.js"><link rel="prefetch" href="/assets/数据结构.html.7ad79b44.js"><link rel="prefetch" href="/assets/算法.html.a1847630.js"><link rel="prefetch" href="/assets/404.html.ca668c5c.js"><link rel="prefetch" href="/assets/404.884736ca.js"><link rel="prefetch" href="/assets/Layout.cf36da62.js">
    <link rel="stylesheet" href="/assets/style.96ee71b5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name can-hide">Abel&#39;s Web</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java基础"><span class="title">Java基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java基础"><span class="title">Java基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="" aria-label="基础知识"><!--[--><!--]--> 基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" class="" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/IO%E6%B5%81.html" class="" aria-label="IO流"><!--[--><!--]--> IO流 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/String.html" class="" aria-label="String"><!--[--><!--]--> String <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html" class="" aria-label="异常处理机制"><!--[--><!--]--> 异常处理机制 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" class="" aria-label="多线程"><!--[--><!--]--> 多线程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html" class="" aria-label="反射机制"><!--[--><!--]--> 反射机制 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Web&amp;HTTP"><span class="title">Web&amp;HTTP</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Web&amp;HTTP"><span class="title">Web&amp;HTTP</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Web&amp;HTTP/notes/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html" class="" aria-label="前端基础"><!--[--><!--]--> 前端基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Web&amp;HTTP/notes/HTTP.html" class="" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80.html" class="" aria-label="数据库基础"><!--[--><!--]--> 数据库基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6.html" class="" aria-label="数据库进阶"><!--[--><!--]--> 数据库进阶 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E5%A4%8D%E6%9D%82SQL%E8%AF%AD%E5%8F%A5.html" class="" aria-label="复杂SQL语句"><!--[--><!--]--> 复杂SQL语句 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/Redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-IOC.html" class="" aria-label="Spring-IOC"><!--[--><!--]--> Spring-IOC <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-AOP.html" class="" aria-label="Spring-AOP"><!--[--><!--]--> Spring-AOP <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-Test.html" class="" aria-label="Spring-Test"><!--[--><!--]--> Spring-Test <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringBoot.html" class="" aria-label="SpringBoot"><!--[--><!--]--> SpringBoot <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringMVC.html" class="" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/MyBatis.html" class="" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/%E5%9F%BA%E4%BA%8EMyBatis%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2.html" class="" aria-label="基于MyBatis的分页查询"><!--[--><!--]--> 基于MyBatis的分页查询 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringSecurity.html" class="" aria-label="SpringSecurity"><!--[--><!--]--> SpringSecurity <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="微服务"><span class="title">微服务</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="微服务"><span class="title">微服务</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5.html" class="" aria-label="微服务概念"><!--[--><!--]--> 微服务概念 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Nacos.html" class="" aria-label="Nacos"><!--[--><!--]--> Nacos <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Dubbo.html" class="" aria-label="Dubbo"><!--[--><!--]--> Dubbo <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Seata.html" class="" aria-label="Seata"><!--[--><!--]--> Seata <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Sentinel.html" class="" aria-label="Sentinel"><!--[--><!--]--> Sentinel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/SpringGateway%E7%BD%91%E5%85%B3.html" class="" aria-label="SpringGateway网关"><!--[--><!--]--> SpringGateway网关 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/ELK.html" class="" aria-label="ELK"><!--[--><!--]--> ELK <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Quartz.html" class="" aria-label="Quartz"><!--[--><!--]--> Quartz <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html" class="" aria-label="消息队列"><!--[--><!--]--> 消息队列 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/notes/%E7%AE%97%E6%B3%95.html" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="其他"><span class="title">其他</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E5%85%B6%E4%BB%96/notes/docker.html" class="" aria-label="Docker"><!--[--><!--]--> Docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="router-link-active router-link-exact-active router-link-active" aria-label="Java常见面试题"><!--[--><!--]--> Java常见面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%85%B6%E4%BB%96/notes/%E5%90%84%E7%B1%BB%E5%B7%A5%E5%85%B7%E3%80%81%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E3%80%81%E5%B8%B8%E7%94%A8%E4%B8%8B%E8%BD%BD.html" class="" aria-label="各类工具、开发文档、常用下载"><!--[--><!--]--> 各类工具、开发文档、常用下载 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://gitee.com/liu-guanzheng/myweb.git" rel="noopener noreferrer" target="_blank" aria-label="Gitee"><!--[--><!--]--> Gitee <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java基础"><span class="title">Java基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java基础"><span class="title">Java基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="" aria-label="基础知识"><!--[--><!--]--> 基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" class="" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/IO%E6%B5%81.html" class="" aria-label="IO流"><!--[--><!--]--> IO流 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/String.html" class="" aria-label="String"><!--[--><!--]--> String <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html" class="" aria-label="异常处理机制"><!--[--><!--]--> 异常处理机制 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" class="" aria-label="多线程"><!--[--><!--]--> 多线程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Java%E5%9F%BA%E7%A1%80/notes/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html" class="" aria-label="反射机制"><!--[--><!--]--> 反射机制 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Web&amp;HTTP"><span class="title">Web&amp;HTTP</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Web&amp;HTTP"><span class="title">Web&amp;HTTP</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/Web&amp;HTTP/notes/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html" class="" aria-label="前端基础"><!--[--><!--]--> 前端基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/Web&amp;HTTP/notes/HTTP.html" class="" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80.html" class="" aria-label="数据库基础"><!--[--><!--]--> 数据库基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6.html" class="" aria-label="数据库进阶"><!--[--><!--]--> 数据库进阶 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/%E5%A4%8D%E6%9D%82SQL%E8%AF%AD%E5%8F%A5.html" class="" aria-label="复杂SQL语句"><!--[--><!--]--> 复杂SQL语句 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/notes/Redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-IOC.html" class="" aria-label="Spring-IOC"><!--[--><!--]--> Spring-IOC <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-AOP.html" class="" aria-label="Spring-AOP"><!--[--><!--]--> Spring-AOP <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/Spring-Test.html" class="" aria-label="Spring-Test"><!--[--><!--]--> Spring-Test <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringBoot.html" class="" aria-label="SpringBoot"><!--[--><!--]--> SpringBoot <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringMVC.html" class="" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/MyBatis.html" class="" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/%E5%9F%BA%E4%BA%8EMyBatis%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2.html" class="" aria-label="基于MyBatis的分页查询"><!--[--><!--]--> 基于MyBatis的分页查询 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/SSM/notes/SpringSecurity.html" class="" aria-label="SpringSecurity"><!--[--><!--]--> SpringSecurity <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="微服务"><span class="title">微服务</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="微服务"><span class="title">微服务</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5.html" class="" aria-label="微服务概念"><!--[--><!--]--> 微服务概念 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Nacos.html" class="" aria-label="Nacos"><!--[--><!--]--> Nacos <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Dubbo.html" class="" aria-label="Dubbo"><!--[--><!--]--> Dubbo <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Seata.html" class="" aria-label="Seata"><!--[--><!--]--> Seata <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Sentinel.html" class="" aria-label="Sentinel"><!--[--><!--]--> Sentinel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/SpringGateway%E7%BD%91%E5%85%B3.html" class="" aria-label="SpringGateway网关"><!--[--><!--]--> SpringGateway网关 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/ELK.html" class="" aria-label="ELK"><!--[--><!--]--> ELK <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/Quartz.html" class="" aria-label="Quartz"><!--[--><!--]--> Quartz <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html" class="" aria-label="消息队列"><!--[--><!--]--> 消息队列 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/notes/%E7%AE%97%E6%B3%95.html" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="其他"><span class="title">其他</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/%E5%85%B6%E4%BB%96/notes/docker.html" class="" aria-label="Docker"><!--[--><!--]--> Docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="router-link-active router-link-exact-active router-link-active" aria-label="Java常见面试题"><!--[--><!--]--> Java常见面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/%E5%85%B6%E4%BB%96/notes/%E5%90%84%E7%B1%BB%E5%B7%A5%E5%85%B7%E3%80%81%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E3%80%81%E5%B8%B8%E7%94%A8%E4%B8%8B%E8%BD%BD.html" class="" aria-label="各类工具、开发文档、常用下载"><!--[--><!--]--> 各类工具、开发文档、常用下载 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://gitee.com/liu-guanzheng/myweb.git" rel="noopener noreferrer" target="_blank" aria-label="Gitee"><!--[--><!--]--> Gitee <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Java常见面试题 <!----></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#java基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java基础"><!--[--><!--]--> Java基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#集合" class="router-link-active router-link-exact-active sidebar-item" aria-label="集合"><!--[--><!--]--> 集合 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#多线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="多线程"><!--[--><!--]--> 多线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#反射" class="router-link-active router-link-exact-active sidebar-item" aria-label="反射"><!--[--><!--]--> 反射 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#对象拷贝" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象拷贝"><!--[--><!--]--> 对象拷贝 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-web" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java Web"><!--[--><!--]--> Java Web <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#异常" class="router-link-active router-link-exact-active sidebar-item" aria-label="异常"><!--[--><!--]--> 异常 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#网络" class="router-link-active router-link-exact-active sidebar-item" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-springmvc" class="router-link-active router-link-exact-active sidebar-item" aria-label="Spring/SpringMVC"><!--[--><!--]--> Spring/SpringMVC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot、springcloud" class="router-link-active router-link-exact-active sidebar-item" aria-label="SpringBoot、SpringCloud"><!--[--><!--]--> SpringBoot、SpringCloud <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis" class="router-link-active router-link-exact-active sidebar-item" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#rabbitmq" class="router-link-active router-link-exact-active sidebar-item" aria-label="RabbitMQ"><!--[--><!--]--> RabbitMQ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#kafka" class="router-link-active router-link-exact-active sidebar-item" aria-label="Kafka"><!--[--><!--]--> Kafka <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#zookeeper" class="router-link-active router-link-exact-active sidebar-item" aria-label="Zookeeper"><!--[--><!--]--> Zookeeper <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#mysql" class="router-link-active router-link-exact-active sidebar-item" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm" class="router-link-active router-link-exact-active sidebar-item" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/%E5%85%B6%E4%BB%96/notes/%E9%9D%A2%E8%AF%95%E9%A2%98.html#数据结构和算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据结构和算法"><!--[--><!--]--> 数据结构和算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><blockquote><p>本文分为十九个模块，分别是：「Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM」 ，如下图所示：</p></blockquote><p><img src="/images/面试题.png" alt="面试题.png"></p><h2 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> Java基础</h2><h6 id="_1-jdk和jre有什么区别" tabindex="-1"><a class="header-anchor" href="#_1-jdk和jre有什么区别" aria-hidden="true">#</a> 1. JDK和JRE有什么区别？</h6><ul><li>JDK：Java Development Kit的简称，Java开发工具包，提供了Java的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，Java运行环境，为Java的运行提供了所需环境。</li></ul><p>具体来说：JDK其实包含了JRE，同时还包含了编译Java源码的编译器Javac，还包含了很多Java程序调试和分析的工具；简单来说：如果你需要运行Java程序，只需安装JRE就可以了，如果你需要编写Java程序，需要安装JDK</p><h6 id="_2-和-equals-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_2-和-equals-的区别是什么" aria-hidden="true">#</a> 2. == 和 equals 的区别是什么？</h6><p>「==解读」</p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相等；</li><li>引用类型：比较的是引用是否相等；</li></ul><p>「equals 解读 」</p><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</p><p>「总结」</p><p>== 对于基本类型来说是值比较，对于引用类型来说比较的是引用；而 equals 默认情况下是应用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h6 id="_3-两个对象的-hashcode-相同-则-equals-也一定为-true-对吗" tabindex="-1"><a class="header-anchor" href="#_3-两个对象的-hashcode-相同-则-equals-也一定为-true-对吗" aria-hidden="true">#</a> 3. 两个对象的 hashCode() 相同，则 equals 也一定为 true，对吗？</h6><p>不对，两个对象的 hashCode() 想通，equals() 不一定 true。</p><h6 id="_4-final-在-java-中有什么作用" tabindex="-1"><a class="header-anchor" href="#_4-final-在-java-中有什么作用" aria-hidden="true">#</a> <strong>4. final 在 Java 中有什么作用？</strong></h6><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后就不能被修改。</li></ul><h6 id="_5-java-中的-math-round-1-5-等于多少" tabindex="-1"><a class="header-anchor" href="#_5-java-中的-math-round-1-5-等于多少" aria-hidden="true">#</a> <strong>5. Java 中的 Math.round(-1.5)等于多少？</strong></h6><p>等于-1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负0.5 是直接舍弃。</p><h6 id="_6-string-属于基础的数据类型吗" tabindex="-1"><a class="header-anchor" href="#_6-string-属于基础的数据类型吗" aria-hidden="true">#</a> 6. String 属于基础的数据类型吗？</h6><p>String 不属于基础类型，基础类型有 8 中，分别是：byte、boolean、char、short、int、long、float、double，而 String 属于对象。</p><h6 id="_7-java-中操作字符串都有哪些类-它们之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_7-java-中操作字符串都有哪些类-它们之间有什么区别" aria-hidden="true">#</a> 7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h6><p>操作字符串的类有：String、StringBuilder、StringBuffer。</p><p>三者的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，软后将指针指向新的 String 对象，而 StringBuilder、StringBuffer 一刻在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是线程不安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h6 id="_8-string-str-i-与-string-str-new-string-i-一样吗" tabindex="-1"><a class="header-anchor" href="#_8-string-str-i-与-string-str-new-string-i-一样吗" aria-hidden="true">#</a> 8. String str = &quot;i&quot; 与 String str = new String(&quot;i&quot;) 一样吗？</h6><p>不一样，因为内存的分配方式不一样。String str = &quot;i&quot; 的方式，Java 虚拟机会将其分配到常量池中；而String str = new String(&quot;i&quot;) 则会被分到堆内存中。</p><h6 id="_9-如果将字符串反转" tabindex="-1"><a class="header-anchor" href="#_9-如果将字符串反转" aria-hidden="true">#</a> 9. 如果将字符串反转？</h6><p>使用 StringBuilder 或者 StringBuffer 的 reverse()方法。</p><h6 id="_10-string-类的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#_10-string-类的常用方法有哪些" aria-hidden="true">#</a> 10. String 类的常用方法有哪些？</h6><ul><li>indexOf()：返回指定字符串的索引</li><li>charAt()：返回指定索引处的字符</li><li>replace()：字符串替换</li><li>trim()：去除字符串两端空白</li><li>split()：分割字符串，返回一个分割后的字符串数组</li><li>getBytes()：返回字符串的 byte 类型数组</li><li>length()：返回字符串长度</li><li>toLowerCase()：将字符串转成小写字母</li><li>toUpperCase()：将字符串转成大写字母</li><li>substring()：截取字符串</li><li>equals()：字符串比较</li></ul><h6 id="_11-抽象类必须要有抽象方法吗" tabindex="-1"><a class="header-anchor" href="#_11-抽象类必须要有抽象方法吗" aria-hidden="true">#</a> 11. 抽象类必须要有抽象方法吗？</h6><p>不需要，抽象类不一定要有抽象方法。</p><h6 id="_12-普通类和抽象类有哪些区别" tabindex="-1"><a class="header-anchor" href="#_12-普通类和抽象类有哪些区别" aria-hidden="true">#</a> 12. 普通类和抽象类有哪些区别？</h6><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h6 id="_13-抽象类能使用-final-修饰吗" tabindex="-1"><a class="header-anchor" href="#_13-抽象类能使用-final-修饰吗" aria-hidden="true">#</a> 13. 抽象类能使用 final 修饰吗？</h6><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 则该类不能被继承，这要彼此就会产生矛盾，所以 final 不能修饰抽象类。</p><h6 id="_14-接口和抽象类有什么区别" tabindex="-1"><a class="header-anchor" href="#_14-接口和抽象类有什么区别" aria-hidden="true">#</a> 14. 接口和抽象类有什么区别？</h6><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口；</li><li>构造函数：抽象类可以有构造函数，接口不能有；</li><li>实现数量：类可以有很多个接口，但是只能继承一个抽象类；</li><li>访问修饰符：接口中的方法默认使用 public 修饰，抽象类中的方法可以是任意访问修饰符</li></ul><h6 id="_15-java-中-io-流分为几种" tabindex="-1"><a class="header-anchor" href="#_15-java-中-io-流分为几种" aria-hidden="true">#</a> 15. Java 中 IO 流分为几种？</h6><p>按功能来分：输入流（input）、输出流（output）；</p><p>按类型来分：字节流、字符流</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节位单位输入输出数据，字符流按 16 位传输以字符位单位输入输出数据。</p><h6 id="_16-bio、nio、aio-有什么区别" tabindex="-1"><a class="header-anchor" href="#_16-bio、nio、aio-有什么区别" aria-hidden="true">#</a> 16. BIO、NIO、AIO 有什么区别？</h6><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用得传统 IO，它的特点是模式简单使用方便，并发处理能力低；</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器通过 Channel（通道）通讯，实现了多路复用；</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非阻塞 IO，异步 IO 的操作基于事件和回调机制。</li></ul><h6 id="_17-files-的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#_17-files-的常用方法有哪些" aria-hidden="true">#</a> 17. Files 的常用方法有哪些？</h6><ul><li>Files.exists()：检查文件路径是否存在；</li><li>Files.createFile()：创建文件；</li><li>Files.createDirectory()：创建文件夹；</li><li>Files.delete()：删除一个文件或目录；</li><li>Files.copy()：复制文件；</li><li>Files.move()：移动文件；</li><li>Files.size()：查看文件个数；</li><li>Files.read()：读取文件；</li><li>Files.write()：写入文件；</li></ul><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><h6 id="_18-java-集合有哪些" tabindex="-1"><a class="header-anchor" href="#_18-java-集合有哪些" aria-hidden="true">#</a> 18. Java 集合有哪些？</h6><p>Java 集合分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><ul><li>Collection <ul><li>List <ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set <ul><li>HashSet</li><li>LinkedSet</li><li>TreeSet</li></ul></li></ul></li><li>Map <ul><li>HashMap <ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>HashTable</li></ul></li></ul><h6 id="_19-collection-和-collections-有什么区别" tabindex="-1"><a class="header-anchor" href="#_19-collection-和-collections-有什么区别" aria-hidden="true">#</a> 19. Collection 和 Collections 有什么区别？</h6><ul><li>Collection 是一个集合接口，它提供了对集合对象进行集合操作额通用接口方法，所有集合都是他的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections.sort(list)。</li></ul><h6 id="_20-list、set、map-之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_20-list、set、map-之间的区别是什么" aria-hidden="true">#</a> 20. List、Set、Map 之间的区别是什么？</h6><p>List、Set、Map 的区别主要提现在两个方面：元素是否有序、是否允许元素重复。</p><p>三者间的区别，如下表：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;"></th><th style="text-align:center;">元素有序</th><th style="text-align:center;">允许元素重复</th></tr></thead><tbody><tr><td style="text-align:center;">List</td><td style="text-align:center;"></td><td style="text-align:center;">是</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">Set</td><td style="text-align:center;">AbstractSet</td><td style="text-align:center;">否</td><td style="text-align:center;">否</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">HashSet</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">TreeSet</td><td style="text-align:center;">是（用二叉树排序）</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">Map</td><td style="text-align:center;">AbstractMap</td><td style="text-align:center;">否</td><td style="text-align:center;">Key 值必须唯一，value 可重复</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">HashMap</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">TreeMap</td><td style="text-align:center;">是（用二叉树排序）</td><td style="text-align:center;"></td></tr></tbody></table><h6 id="_21-hashmap-和-hashtable-有什么区别" tabindex="-1"><a class="header-anchor" href="#_21-hashmap-和-hashtable-有什么区别" aria-hidden="true">#</a> 21. HashMap 和 HashTable 有什么区别？</h6><ul><li>存储：HashMap 允许 key 和 value 为null，而 HashTable 不允许；</li><li>线程安全：HashTable 是线程安全的，而 HashMap 是非线程安全的；</li><li>推荐使用：在 HashTable 的类注解可以看到，HashTable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrenHashMap 替代。</li></ul><h6 id="_22-如何决定使用-hashmap-还是-treemap" tabindex="-1"><a class="header-anchor" href="#_22-如何决定使用-hashmap-还是-treemap" aria-hidden="true">#</a> 22. 如何决定使用 HashMap 还是 TreeMap？</h6><p>对于在 Map 中插入、删除、定位一个元素这样的操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果要对一个 key 集合进行有序的遍历，那么 TreeMap 是更好的选择。</p><h6 id="_23-说一下-hashmap-的实现原理" tabindex="-1"><a class="header-anchor" href="#_23-说一下-hashmap-的实现原理" aria-hidden="true">#</a> 23. 说一下 HashMap 的实现原理？</h6><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h6 id="_24-说一下-hashset-的实现原理" tabindex="-1"><a class="header-anchor" href="#_24-说一下-hashset-的实现原理" aria-hidden="true">#</a> 24. 说一下 HashSet 的实现原理？</h6><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h6 id="_25-arraylist-和-linkedlist-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_25-arraylist-和-linkedlist-的区别是什么" aria-hidden="true">#</a> 25. ArrayList 和 LinkedList 的区别是什么？</h6><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>数据访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首行的增加和删除操作，LinkedList 要比 ArrayList 效率高，因为ArrayList 增删操作要影响数组内其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而插入和删除操作较多时，更推荐使用 LinkedList。</p><h6 id="_26-如何实现数组和-list-之间的转换" tabindex="-1"><a class="header-anchor" href="#_26-如何实现数组和-list-之间的转换" aria-hidden="true">#</a> 26. 如何实现数组和 List 之间的转换？</h6><ul><li>数组转 List：使用 Arrays.asList(arr)进行转换；</li><li>List 转数组：使用 List 自带的toArray() 方法。</li></ul><h6 id="_27-arraylist-和-vector-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_27-arraylist-和-vector-的区别是什么" aria-hidden="true">#</a> 27. ArrayList 和 Vector 的区别是什么？</h6><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的；</li><li>性能：ArrayList 在性能方面要优于 Vector；</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态调整容量，只不过 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><h6 id="_28-array-和-arraylist-有何区别" tabindex="-1"><a class="header-anchor" href="#_28-array-和-arraylist-有何区别" aria-hidden="true">#</a> 28. Array 和 ArrayList 有何区别？</h6><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象；</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的；</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h6 id="_29-在-queue-中-poll-和-remove-有什么区别" tabindex="-1"><a class="header-anchor" href="#_29-在-queue-中-poll-和-remove-有什么区别" aria-hidden="true">#</a> 29. 在 Queue 中 poll() 和 remove() 有什么区别？</h6><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll() 会返回 null，而 remove() 会直接抛出 NoSuchElementException 异常。</li></ul><h6 id="_30-哪些集合类是线程安全的" tabindex="-1"><a class="header-anchor" href="#_30-哪些集合类是线程安全的" aria-hidden="true">#</a> 30. 哪些集合类是线程安全的？</h6><p>Vector、HashTable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK1.5 之后随着 Java.util.concurrent并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h6 id="_31-迭代器-iterator-是什么" tabindex="-1"><a class="header-anchor" href="#_31-迭代器-iterator-是什么" aria-hidden="true">#</a> 31. 迭代器 Iterator 是什么？</h6><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器不允许调用者在迭代过程中移除元素。</p><h6 id="_32-iterator-怎么使用-有什么特点" tabindex="-1"><a class="header-anchor" href="#_32-iterator-怎么使用-有什么特点" aria-hidden="true">#</a> 32. Iterator 怎么使用？有什么特点？</h6><p>Iterator 使用代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">String</span> obj <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h6 id="_33-iterator-和-listiterator-有什么区别" tabindex="-1"><a class="header-anchor" href="#_33-iterator-和-listiterator-有什么区别" aria-hidden="true">#</a> 33. Iterator 和 ListIterator 有什么区别？</h6><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List；</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）；</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或者后面元素的索引位置。</li></ul><h6 id="_34-怎么确保一个集合不能被修改" tabindex="-1"><a class="header-anchor" href="#_34-怎么确保一个集合不能被修改" aria-hidden="true">#</a> 34. 怎么确保一个集合不能被修改？</h6><p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> 多线程</h2><h6 id="_35-并行和并发有什么区别" tabindex="-1"><a class="header-anchor" href="#_35-并行和并发有什么区别" aria-hidden="true">#</a> 35. 并行和并发有什么区别？</h6><ul><li>并行：多个处理器或多核处理器同时处理多个任务；</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流（交替）执行，从逻辑上来看那些任务是同时执行。</li></ul><h6 id="_36-线程和进程的区别" tabindex="-1"><a class="header-anchor" href="#_36-线程和进程的区别" aria-hidden="true">#</a> 36. 线程和进程的区别？</h6><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h6 id="_37-守护线程是什么" tabindex="-1"><a class="header-anchor" href="#_37-守护线程是什么" aria-hidden="true">#</a> 37. 守护线程是什么？</h6><p>守护线程是运行在后台的一种特殊线程，它独立于控制终端并且周期性地执行某种任务或者等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h6 id="_38-创建线程有哪几种方式" tabindex="-1"><a class="header-anchor" href="#_38-创建线程有哪几种方式" aria-hidden="true">#</a> 38. 创建线程有哪几种方式？</h6><p>创建线程有三种方式：</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><h6 id="_39-说一下-runnable-和-callable-有什么区别" tabindex="-1"><a class="header-anchor" href="#_39-说一下-runnable-和-callable-有什么区别" aria-hidden="true">#</a> 39. 说一下 runnable 和 callable 有什么区别？</h6><p>runnable 没有返回值，callable 有返回值，callable 可以看做是 runnable 的补充。</p><h6 id="_40-线程有哪些状态" tabindex="-1"><a class="header-anchor" href="#_40-线程有哪些状态" aria-hidden="true">#</a> 40. 线程有哪些状态？</h6><p>线程的状态：</p><ul><li>NEW 尚未启动</li><li>RUNNABLE 正在执行</li><li>BLOCKED 阻塞的（被同步锁或者 IO 锁阻塞）</li><li>WAITING 永久等待状态</li><li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li><li>TERMINATED 执行完成</li></ul><h6 id="_41-sleep-和-wait-有什么区别" tabindex="-1"><a class="header-anchor" href="#_41-sleep-和-wait-有什么区别" aria-hidden="true">#</a> 41. sleep() 和 wait() 有什么区别？</h6><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object；</li><li>释放锁：sleep() 不释放锁，wait() 释放锁；</li><li>用法不同：sleep() 时间到会自动恢复，wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul><h6 id="_42-notify-和-notifyall-有什么区别" tabindex="-1"><a class="header-anchor" href="#_42-notify-和-notifyall-有什么区别" aria-hidden="true">#</a> 42. notify() 和 notifyAll() 有什么区别？</h6><p>notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将所有线程由等待池转移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池被释放后再次参与竞争。而notify()只会唤醒一个线程，具体唤醒哪一个由虚拟机控制。</p><h6 id="_43-线程的run-和-start-有什么区别" tabindex="-1"><a class="header-anchor" href="#_43-线程的run-和-start-有什么区别" aria-hidden="true">#</a> 43. 线程的run() 和 start() 有什么区别？</h6><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而start() 只能调用一次。</p><h6 id="_44-创建线程池有哪几种方式" tabindex="-1"><a class="header-anchor" href="#_44-创建线程池有哪几种方式" aria-hidden="true">#</a> 44. 创建线程池有哪几种方式？</h6><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务都是被顺序执行的，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其给变线程数目；</li><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明的特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移除缓存；长时间闲置时，这种线程池不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>newScheduledThreadPool(int corePoolSize)：和ewSingleThreadScheduledExecutor() 类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：这是一个经常被忽略的线程池，Java8 才计入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面 1-3 创建方式都是对 ThreadPoolExecutor的封装。</li></ul><h6 id="_45-线程池有哪些状态" tabindex="-1"><a class="header-anchor" href="#_45-线程池有哪些状态" aria-hidden="true">#</a> 45. 线程池有哪些状态？</h6><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务；</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；</li><li>STOP：不接受新的任务提交，不在处理等待队列中的任务，中断正在执行任务的线程；</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态转换为 TIDYING 状态是，会执行钩子方法 terminated()；</li><li>TERMINATED：terminated()方法结束后，线程池的状态会变成这个。</li></ul><h6 id="_46-线程池中-submit-和execute-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_46-线程池中-submit-和execute-方法有什么区别" aria-hidden="true">#</a> 46. 线程池中 submit() 和execute() 方法有什么区别？</h6><ul><li>execute()：只能执行 Runnable 类型的任务；</li><li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li></ul><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h6 id="_47-在-java-程序中怎么保证多线程的运行安全" tabindex="-1"><a class="header-anchor" href="#_47-在-java-程序中怎么保证多线程的运行安全" aria-hidden="true">#</a> 47. 在 Java 程序中怎么保证多线程的运行安全？</h6><ul><li>方法一：使用安全类，比如Java.util.concurrent下的类；</li><li>方法二：使用自动锁 synchronized；</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁示例代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;获得锁&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// TODO: handle exception</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;释放锁&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="_48-多线程中-synchronized-锁升级的原理是什么" tabindex="-1"><a class="header-anchor" href="#_48-多线程中-synchronized-锁升级的原理是什么" aria-hidden="true">#</a> 48. 多线程中 synchronized 锁升级的原理是什么？</h6><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁位轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用得对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低锁带来的性能消耗。在 Java6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h6 id="_49-什么是死锁" tabindex="-1"><a class="header-anchor" href="#_49-什么是死锁" aria-hidden="true">#</a> 49. 什么是死锁？</h6><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，从而发生的阻塞现象，我们称为死锁。</p><h6 id="_50-怎么方式死锁" tabindex="-1"><a class="header-anchor" href="#_50-怎么方式死锁" aria-hidden="true">#</a> 50. 怎么方式死锁？</h6><ul><li>尽量使用 tryLock(long timeout,TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁；</li><li>尽量使用 Java.util.concurrent并发类代替自己手写锁；</li><li>尽量江都锁的使用粒度，尽量不要几个功能用一把锁；</li><li>尽量减少同步的代码块。</li></ul><h6 id="_51-threadlocal-是什么-有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#_51-threadlocal-是什么-有哪些使用场景" aria-hidden="true">#</a> 51. ThreadLocal 是什么？有哪些使用场景？</h6><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接盒 session 管理等。</p><h6 id="_52-说一下-synchronized-底层实现原理" tabindex="-1"><a class="header-anchor" href="#_52-说一下-synchronized-底层实现原理" aria-hidden="true">#</a> 52. 说一下 synchronized 底层实现原理？</h6><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java6 之前，monitor 的实现完全依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作时一个无差别的重量级操作，性能也很低。但在 Java6 的时候，Java 虚拟机对此进行了大刀阔斧的改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁、轻量级锁和重量级锁，大大改进了其性能。</p><h6 id="_53-synchronized-和-volatile-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_53-synchronized-和-volatile-的区别是什么" aria-hidden="true">#</a> 53. synchronized 和 volatile 的区别是什么？</h6><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段；</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性；</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h6 id="_54-synchronized-和-lock-有什么区别" tabindex="-1"><a class="header-anchor" href="#_54-synchronized-和-lock-有什么区别" aria-hidden="true">#</a> 54. synchronized 和 Lock 有什么区别？</h6><ul><li>synchronized 可以给类、方法、代码块加锁；而 Lock 只能给代码块加锁；</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 Lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁；</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h6 id="_55-synchronized-和-reentrantlock-区别是什么" tabindex="-1"><a class="header-anchor" href="#_55-synchronized-和-reentrantlock-区别是什么" aria-hidden="true">#</a> 55. synchronized 和 ReentrantLock 区别是什么？</h6><p>synchronized 早起的实现比较低效，对于 ReentrantLock，大多是场景性能都相差较大，但是在 Java6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开始锁；</li><li>ReentrantLock 只适用于代码块，而 synchronized 可用于修饰方法、代码块等。</li></ul><h6 id="_56-说一下-atomic-的原理" tabindex="-1"><a class="header-anchor" href="#_56-说一下-atomic-的原理" aria-hidden="true">#</a> 56. 说一下 atomic 的原理？</h6><p>atomic 主要利用 CAS（Compare And Swap）和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2><h6 id="_57-什么是反射" tabindex="-1"><a class="header-anchor" href="#_57-什么是反射" aria-hidden="true">#</a> 57. 什么是反射？</h6><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的功能称为 Java 的反射机制。</p><h6 id="_58-什么是-java-序列化-什么情况下需要序列化" tabindex="-1"><a class="header-anchor" href="#_58-什么是-java-序列化-什么情况下需要序列化" aria-hidden="true">#</a> 58. 什么是 Java 序列化？什么情况下需要序列化？</h6><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以吧保存的对象状态再读出来。</p><p>以下情况需要使用 Java 序列化：</p><ul><li>想把内存中的对象保存到一个文件中或者数据库中的时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过 RMI（远程方法调用） 传输对象的时候。</li></ul><h6 id="_59-动态代理是什么-有哪些应用" tabindex="-1"><a class="header-anchor" href="#_59-动态代理是什么-有哪些应用" aria-hidden="true">#</a> 59. 动态代理是什么？有哪些应用？</h6><p>动态代理是运行时动态生成代理类。</p><p>动态代理的应用有 AOP、hibernate 数据查询、测试框架的后端 mock、rpc、Java 注解对象获取等。</p><h6 id="_60-怎么实现动态代理" tabindex="-1"><a class="header-anchor" href="#_60-怎么实现动态代理" aria-hidden="true">#</a> 60. 怎么实现动态代理？</h6><p>JDk 原生动态代理和 CGLIB 动态代理。JDK 原生动态代理是基于接口实现的，而 CGLIB 是基于继承当前类的子类实现的。</p><h2 id="对象拷贝" tabindex="-1"><a class="header-anchor" href="#对象拷贝" aria-hidden="true">#</a> 对象拷贝</h2><h6 id="_61-为什么要使用克隆" tabindex="-1"><a class="header-anchor" href="#_61-为什么要使用克隆" aria-hidden="true">#</a> 61. 为什么要使用克隆？</h6><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h6 id="_62-如何实现对象克隆" tabindex="-1"><a class="header-anchor" href="#_62-如何实现对象克隆" aria-hidden="true">#</a> 62. 如何实现对象克隆？</h6><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone()方法；</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h6 id="_63-深拷贝和浅拷贝区别是什么" tabindex="-1"><a class="header-anchor" href="#_63-深拷贝和浅拷贝区别是什么" aria-hidden="true">#</a> 63. 深拷贝和浅拷贝区别是什么？</h6><ul><li>浅拷贝：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li><li>深拷贝：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li></ul><h2 id="java-web" tabindex="-1"><a class="header-anchor" href="#java-web" aria-hidden="true">#</a> Java Web</h2><h6 id="_64-jsp-和-servlet-有什么区别" tabindex="-1"><a class="header-anchor" href="#_64-jsp-和-servlet-有什么区别" aria-hidden="true">#</a> 64. JSP 和 servlet 有什么区别？</h6><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于：servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h6 id="_65-jsp-有哪些内置对象-作用分别是什么" tabindex="-1"><a class="header-anchor" href="#_65-jsp-有哪些内置对象-作用分别是什么" aria-hidden="true">#</a> 65. JSP 有哪些内置对象？作用分别是什么？</h6><p>JSP 有 9 大内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web 应用的配置对象；</li><li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h6 id="_66-说一下-jsp-的-4-种作用域" tabindex="-1"><a class="header-anchor" href="#_66-说一下-jsp-的-4-种作用域" aria-hidden="true">#</a> 66. 说一下 JSP 的 4 种作用域？</h6><ul><li>page：代表与一个页面相关的对象和属性。</li><li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li><li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h6 id="_67-session-和-cookie-有什么区别" tabindex="-1"><a class="header-anchor" href="#_67-session-和-cookie-有什么区别" aria-hidden="true">#</a> 67. session 和 cookie 有什么区别？</h6><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端；</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改；</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制；</li><li>存储的多样性：session 可以存储在 Redis 、数据库、应用程序中；而 cookie 只能存储在浏览器中。</li></ul><h6 id="_68-说一下-session-的工作原理" tabindex="-1"><a class="header-anchor" href="#_68-说一下-session-的工作原理" aria-hidden="true">#</a> 68. 说一下 session 的工作原理？</h6><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完成后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存中找到与之对应的 session，这样就可以正常工作了。</p><h6 id="_69-如果客户端禁止-cookie-session-还能用吗" tabindex="-1"><a class="header-anchor" href="#_69-如果客户端禁止-cookie-session-还能用吗" aria-hidden="true">#</a> 69. 如果客户端禁止 cookie，session 还能用吗？</h6><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h6 id="_70-spring-mvc-和-struts-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_70-spring-mvc-和-struts-的区别是什么" aria-hidden="true">#</a> 70. spring MVC 和 struts 的区别是什么？</h6><ul><li>拦截级别：struts2 是类级别的拦截；springMVC 是方法级别的拦截。</li><li>数据独立性：springMVC 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结构通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但起所有 action 变量是共享的，这不会影响程序运行，却给我们编码和都城叙事带来了一定的麻烦。</li><li>拦截机制：struts2 有自己的 interceptor 机制，springMVC 用的是独立的 AOP 方式，这样导致 struts2 的配置文件量比 springMVC 大。</li><li>对 ajax 的支持：springMVC 继承了 ajax，所以 ajax 使用很方便，只需要一个注解@ResponseBody接可以实现了；而 struts2 一般需要安转插件或者自己写代码才行。</li></ul><h6 id="_71-如何避免-sql-注入" tabindex="-1"><a class="header-anchor" href="#_71-如何避免-sql-注入" aria-hidden="true">#</a> 71. 如何避免 SQL 注入？</h6><ul><li>使用预处理 PrepareStatement；</li><li>使用正则表达式过滤掉字符中的特殊字符。</li></ul><h6 id="_72-什么是-xss-攻击-如何避免" tabindex="-1"><a class="header-anchor" href="#_72-什么是-xss-攻击-如何避免" aria-hidden="true">#</a> 72. 什么是 XSS 攻击，如何避免？</h6><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h6 id="_73-什么是-csrf-攻击-如何避免" tabindex="-1"><a class="header-anchor" href="#_73-什么是-csrf-攻击-如何避免" aria-hidden="true">#</a> 73. 什么是 CSRF 攻击，如何避免？</h6><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>防御手段：</p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul><h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常" aria-hidden="true">#</a> 异常</h2><h6 id="_74-throw-和-throws-的区别" tabindex="-1"><a class="header-anchor" href="#_74-throw-和-throws-的区别" aria-hidden="true">#</a> 74. throw 和 throws 的区别？</h6><ul><li>throw：是真实抛出一个异常；</li><li>throws：是声明可能会抛出一个异常。</li></ul><h6 id="_75-final、finally、finalize-有什么区别" tabindex="-1"><a class="header-anchor" href="#_75-final、finally、finalize-有什么区别" aria-hidden="true">#</a> 75. final、finally、finalize 有什么区别？</h6><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和变量不能再被改变，只能使用；</li><li>finally：是 try...catch...finally 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但是如果 finally 部分存在，则一定会执行 finally 里面的代码；</li><li>finalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li></ul><h6 id="_76-try-catch-finally-中哪个部分可以省略" tabindex="-1"><a class="header-anchor" href="#_76-try-catch-finally-中哪个部分可以省略" aria-hidden="true">#</a> 76. try-catch-finally 中哪个部分可以省略？</h6><p>try-catch-finally 中 catch 和 finally 都可以被省略，但是不能同时省略。</p><h6 id="_77-try-catch-finally中-如果-catch-中-return-了-finally-还会执行吗" tabindex="-1"><a class="header-anchor" href="#_77-try-catch-finally中-如果-catch-中-return-了-finally-还会执行吗" aria-hidden="true">#</a> 77. try-catch-finally中，如果 catch 中 return 了，finally 还会执行吗？</h6><p>finally 一定会执行，即是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完后，才会执行。</p><h6 id="_78-常见的异常类有哪些" tabindex="-1"><a class="header-anchor" href="#_78-常见的异常类有哪些" aria-hidden="true">#</a> 78. 常见的异常类有哪些？</h6><ul><li>NullPointerException 空指针异常</li><li>ClassNotFoundException 指定类不存在</li><li>NumberFormatException 字符串转换为数字异常</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h2><h6 id="_79-http响应码301和302代表的是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#_79-http响应码301和302代表的是什么-有什么区别" aria-hidden="true">#</a> 79. http响应码301和302代表的是什么？有什么区别？</h6><ul><li>301：永久重定向</li><li>302：暂时重定向</li></ul><p>它们的区别是，301对搜索引擎优化（SEO）更加有利；302有被提示为网络拦截的风险。</p><h6 id="_80-forward和redirect的区别" tabindex="-1"><a class="header-anchor" href="#_80-forward和redirect的区别" aria-hidden="true">#</a> 80. forward和redirect的区别？</h6><p>forward是转发，redirect是重定向；</p><ul><li>地址栏url西那是：forward url不会发生改变，redirect url会发生改变；</li><li>数据共享： forward可以共享request里的数据，redirect不能共享；</li><li>效率：forward比redirect效率高。</li></ul><h6 id="_81-简述tcp和udp的区别" tabindex="-1"><a class="header-anchor" href="#_81-简述tcp和udp的区别" aria-hidden="true">#</a> 81. 简述tcp和udp的区别？</h6><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>tcp面向连接；udp面向非连接，即发送数据前不需要建立连接；</li><li>tcp提供可靠的服务（数据传输），udp无法保证；</li><li>tcp面向字节流，udp面向报文；</li><li>tcp传输数据慢，udp传输数据快。</li></ul><h6 id="_82-tcp为什么要三次握手-两次不行吗" tabindex="-1"><a class="header-anchor" href="#_82-tcp为什么要三次握手-两次不行吗" aria-hidden="true">#</a> 82. tcp为什么要三次握手，两次不行吗？</h6><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p><h6 id="_83-说一下tcp粘包时真没产生的" tabindex="-1"><a class="header-anchor" href="#_83-说一下tcp粘包时真没产生的" aria-hidden="true">#</a> 83. 说一下tcp粘包时真没产生的？</h6><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul><h6 id="_84-osi七层模型都有哪些" tabindex="-1"><a class="header-anchor" href="#_84-osi七层模型都有哪些" aria-hidden="true">#</a> 84. OSI七层模型都有哪些？</h6><ul><li>物理层：利用传输介质位数据链路层提供物理连接，实现比特流的透明传输</li><li>数据链路层：负责建立和管理节点间的链路</li><li>网络层： 通过路由选择算法，为报文或分组通过通信子网选择最适当的路径</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种任务</li></ul><h6 id="_85-get和post请求有哪些区别" tabindex="-1"><a class="header-anchor" href="#_85-get和post请求有哪些区别" aria-hidden="true">#</a> 85. get和post请求有哪些区别？</h6><ul><li>get请求会被浏览器主动缓存，post不会；</li><li>get传输参数有大小限制，而post没有；</li><li>post参数传输更安全，get的参数会明文显示在url上，post不会。</li></ul><h6 id="_86-如何实现跨域" tabindex="-1"><a class="header-anchor" href="#_86-如何实现跨域" aria-hidden="true">#</a> 86. 如何实现跨域？</h6><ul><li>服务器端运行跨域 设置CORS等于*；</li><li>在单个接口使用注解@CrossOrigin运行跨域；</li><li>使用jsonp跨域；</li></ul><h6 id="_87-说一下jsonp实现原理" tabindex="-1"><a class="header-anchor" href="#_87-说一下jsonp实现原理" aria-hidden="true">#</a> 87. 说一下JSONP实现原理？</h6><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><h6 id="_88-说一下你熟悉的设计模式" tabindex="-1"><a class="header-anchor" href="#_88-说一下你熟悉的设计模式" aria-hidden="true">#</a> 88. 说一下你熟悉的设计模式？</h6><ul><li>单例模式：保证被创建一次，节省系统开销。</li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li></ul><h6 id="_89-简单工厂和抽象工厂有什么区别" tabindex="-1"><a class="header-anchor" href="#_89-简单工厂和抽象工厂有什么区别" aria-hidden="true">#</a> 89.简单工厂和抽象工厂有什么区别？</h6><ul><li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li><li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li><li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li></ul><h2 id="spring-springmvc" tabindex="-1"><a class="header-anchor" href="#spring-springmvc" aria-hidden="true">#</a> Spring/SpringMVC</h2><h6 id="_90-为什么要使用spring" tabindex="-1"><a class="header-anchor" href="#_90-为什么要使用spring" aria-hidden="true">#</a> 90. 为什么要使用spring？</h6><ul><li>spring提供IOC技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦</li><li>spring提供了事务支持，使得事务操作的更加方便</li><li>spring提供了面向切面编程，这样可以方便的处理某一类的问题</li><li>更方便的框架继承，spring可以很方便的继承其他框架，比如Mybatis、hibernate等</li></ul><h6 id="_91-解释一下什么是aop" tabindex="-1"><a class="header-anchor" href="#_91-解释一下什么是aop" aria-hidden="true">#</a> 91. 解释一下什么是AOP？</h6><p>AOP是面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><p>简单来说就是泳衣处理某一“切面”（类）的问题的编程思想，比如统一处理日志，异常等。</p><h6 id="_92-解释一下什么是ioc" tabindex="-1"><a class="header-anchor" href="#_92-解释一下什么是ioc" aria-hidden="true">#</a> 92. 解释一下什么是IOC？</h6><p>IOC：Inversion Of Control（控制反转）是spring的核心，对于Spring框架来说，就是有Spring来负责控制对象的生命周期和对象间的关系。</p><p>简单来说，控制指的是当前对象的内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类，第三方容器）来管理。</p><h6 id="_93-spring有哪些主要模块" tabindex="-1"><a class="header-anchor" href="#_93-spring有哪些主要模块" aria-hidden="true">#</a> 93. Spring有哪些主要模块？</h6><ul><li>Spring Core：框架的最基础部分，提供IOC和ID特性；</li><li>Spring Context：构建于Core封装包基础上的context封装包，提供了一种框架式的对象访问方法；</li><li>Spring DAO：Data Access Object提供了JDBC的抽象层；</li><li>Spring AOP：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>Spring Web：提供了针对Web开发的继承特性，例如文件上传，李彤servlet listeners进行IOC容器初始化和针对Web的ApplicationContext，</li><li>Spring Web MVC：Spring中的MVC封装包提供了Web应用的Model-View-Controller（MVC）的实现。</li></ul><h6 id="_94-spring常用的注入方式有哪些" tabindex="-1"><a class="header-anchor" href="#_94-spring常用的注入方式有哪些" aria-hidden="true">#</a> 94. Spring常用的注入方式有哪些？</h6><ul><li>setter属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul><h6 id="_95-spring中的bean是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#_95-spring中的bean是线程安全的吗" aria-hidden="true">#</a> 95. Spring中的bean是线程安全的吗？</h6><p>Spring中bean默认是单例模式，Spring框架并没有对单例bean进行多线程的封装处理。</p><p>实际上大部分时候Spring bean是无状态的（比如dao类），所以某种程度上来说bean也是安全的，但如果bean有状态的话（比如view model对象），那就要开发者自己去保证线程安全了，最简单的就是改变bean的作用域，把“singleton”更变为“prototype”，这样请求bean相当于new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能</li><li>无状态就是不会保存数据</li></ul><h6 id="_96-spring支持集中bean的作用域" tabindex="-1"><a class="header-anchor" href="#_96-spring支持集中bean的作用域" aria-hidden="true">#</a> 96. Spring支持集中bean的作用域？</h6><p>Spring支持5中作用域，如下：</p><ul><li>singleton：Spring IOC容器中只存在一个bean实例，bean以单例模式存在，是系统默认值；</li><li>prototype：每次从容器调用bean时都会创建一个新的实例，即每次getBean()相当于执行new Bean()操作；</li><li>request：每次http请求会创建一个bean；</li><li>session：同一个http session共享一个bean实例；</li><li>golbal-session：用于portlet容器，因为每个porlet有单独的session，globalsession提供一个全局性的http session。</li></ul><blockquote><p>使用prototype作用域需要慎重的思考，因为频繁创建和销毁bean会带来很大的性能开销。 {.is-warning}</p></blockquote><h6 id="_97-spring自动装配bean有哪些方式" tabindex="-1"><a class="header-anchor" href="#_97-spring自动装配bean有哪些方式" aria-hidden="true">#</a> 97. Spring自动装配bean有哪些方式？</h6><ul><li>no：默认值，表示没有自动装配，应使用显示bean引用进行装配。</li><li>byName：它根据bean的名称注入对象依赖项。</li><li>byType：它根据类型注入对象依赖项。</li><li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li><li>autodetect：容器首先通过构造函数使用autowire装配，如果不能，则通过byType自动装配。</li></ul><h6 id="_98-spring事务实现方式有哪些" tabindex="-1"><a class="header-anchor" href="#_98-spring事务实现方式有哪些" aria-hidden="true">#</a> 98. spring事务实现方式有哪些？</h6><ul><li>声明式事务：声明式事务也有两种实现方式，基于xml配置文件的方式和注解方式（在类上添加@Transaction注解）；</li><li>编码方式：提供编码的形式管理和维护事务。</li></ul><h6 id="_99-说一下spring的事务隔离" tabindex="-1"><a class="header-anchor" href="#_99-说一下spring的事务隔离" aria-hidden="true">#</a> 99. 说一下Spring的事务隔离？</h6><p>Spring有五大隔离级别，默认值为ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ul><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据设置的是什么就用什么。</li><li>READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取；</li><li>READ_COMMITTED：提交读，一个事务提交后才能被其它事务读取到；</li><li>REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据；</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><h6 id="_100-说一下springmvc运行流程" tabindex="-1"><a class="header-anchor" href="#_100-说一下springmvc运行流程" aria-hidden="true">#</a> 100. 说一下SpringMVC运行流程？</h6><ul><li>SpringMVC先将请求发送给DispatcherServlet；</li><li>DispatcherServlet查询一个或多个HandlerMapping，赵铎处理请求的Controller；</li><li>DispatcherServlet再将请求提交到对应的Controller；</li><li>Controller进行业务逻辑处理后，会返回一个ModelAndView；</li><li>Dispatcher查询一个或多个ViewResolver视图解析器，找到ModelAndView对象指定的视图对象。</li><li>视图对象负责渲染返回给客户端。</li></ul><h6 id="_101-springmvc有哪些组件" tabindex="-1"><a class="header-anchor" href="#_101-springmvc有哪些组件" aria-hidden="true">#</a> 101. SpringMVC有哪些组件？</h6><ul><li>前置控制器DispatcherServlet；</li><li>映射控制器HandlerMapping</li><li>处理器Controller；</li><li>模型和视图ModelAndView；</li><li>视图解析器ViewResolver。</li></ul><h6 id="_102-requestmapping的作用是什么" tabindex="-1"><a class="header-anchor" href="#_102-requestmapping的作用是什么" aria-hidden="true">#</a> 102. @RequestMapping的作用是什么？</h6><p>将http请求映射到相应的类、方法上。</p><h6 id="_103-autowired的作用是什么" tabindex="-1"><a class="header-anchor" href="#_103-autowired的作用是什么" aria-hidden="true">#</a> 103. @Autowired的作用是什么？</h6><p>@Autowired它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired的使用来消除setter/getter方法</p><h2 id="springboot、springcloud" tabindex="-1"><a class="header-anchor" href="#springboot、springcloud" aria-hidden="true">#</a> SpringBoot、SpringCloud</h2><h6 id="_104-什么是springboot" tabindex="-1"><a class="header-anchor" href="#_104-什么是springboot" aria-hidden="true">#</a> 104. 什么是SpringBoot？</h6><p>SpringBoot是为Spring服务的，是用来简化新Spring应用的初始搭建以及开发过程的。</p><h6 id="_105-为什么要用springboot" tabindex="-1"><a class="header-anchor" href="#_105-为什么要用springboot" aria-hidden="true">#</a> 105. 为什么要用SpringBoot？</h6><ul><li>配置简单</li><li>独立运行</li><li>自动装配</li><li>无代码生成和xml配置</li><li>提供应用监控</li><li>易上手</li><li>提高开发效率</li></ul><h6 id="_106-springboot核心配置文件是什么" tabindex="-1"><a class="header-anchor" href="#_106-springboot核心配置文件是什么" aria-hidden="true">#</a> 106. SpringBoot核心配置文件是什么？</h6><p>springboot核心的两个配置文件：</p><ul><li>bootstrap（.yml或者.properties）：bootstrap由父ApplicationContext加载的，比application有限再加，且bootstrap里面的属性不能被覆盖；</li><li>application（.yml或者.properties）：用于SpringBoot项目的自动化配置。</li></ul><h6 id="_107-spring-boot-配置文件有哪几种类型-它们有什么区别" tabindex="-1"><a class="header-anchor" href="#_107-spring-boot-配置文件有哪几种类型-它们有什么区别" aria-hidden="true">#</a> 107.spring boot 配置文件有哪几种类型？它们有什么区别？</h6><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。 yml 格式不支持 @PropertySource 注解导入。</p><h6 id="_108-springboot有哪些方式可以实现热部署" tabindex="-1"><a class="header-anchor" href="#_108-springboot有哪些方式可以实现热部署" aria-hidden="true">#</a> 108. SpringBoot有哪些方式可以实现热部署？</h6><ul><li>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</li><li>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</li></ul><h6 id="_109-jpa-和-hibernate-有什么区别" tabindex="-1"><a class="header-anchor" href="#_109-jpa-和-hibernate-有什么区别" aria-hidden="true">#</a> 109. jpa 和 hibernate 有什么区别？</h6><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><h6 id="_110-什么是-spring-cloud" tabindex="-1"><a class="header-anchor" href="#_110-什么是-spring-cloud" aria-hidden="true">#</a> 110. 什么是 spring cloud？</h6><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h6 id="_111-spring-cloud-断路器的作用是什么" tabindex="-1"><a class="header-anchor" href="#_111-spring-cloud-断路器的作用是什么" aria-hidden="true">#</a> 111. spring cloud 断路器的作用是什么？</h6><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h6 id="_112-spring-cloud-的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#_112-spring-cloud-的核心组件有哪些" aria-hidden="true">#</a> 112. spring cloud 的核心组件有哪些？</h6><ul><li>Eureka：服务注册于发现。</li><li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li><li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li><li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li><li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li></ul><h2 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> MyBatis</h2><h6 id="_113-mybatis-中-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_113-mybatis-中-和-的区别是什么" aria-hidden="true">#</a> 113. MyBatis 中 #{}和 ${}的区别是什么？</h6><p>#{}是预编译处理，${}是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><h6 id="_114-mybatis-有几种分页方式" tabindex="-1"><a class="header-anchor" href="#_114-mybatis-有几种分页方式" aria-hidden="true">#</a> 114. MyBatis 有几种分页方式？</h6><ul><li>逻辑分页：使用MyBatis自带的RowBounds进行分页，它是一次性查询很多数据，然后在数据中再进行检索；</li><li>物理分页：自己手写SQL分页或使用分页插件PageHelper，去数据库查询指定条数的分页数据的形式。</li></ul><h6 id="_115-rowbounds-是一次性查询全部结果吗-为什么" tabindex="-1"><a class="header-anchor" href="#_115-rowbounds-是一次性查询全部结果吗-为什么" aria-hidden="true">#</a> 115. RowBounds 是一次性查询全部结果吗？为什么？</h6><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><h6 id="_116-mybatis-逻辑分页和物理分页的区别是什么" tabindex="-1"><a class="header-anchor" href="#_116-mybatis-逻辑分页和物理分页的区别是什么" aria-hidden="true">#</a> 116. MyBatis 逻辑分页和物理分页的区别是什么？</h6><ul><li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li><li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li></ul><h6 id="_117-mybatis-是否支持延迟加载-延迟加载的原理是什么" tabindex="-1"><a class="header-anchor" href="#_117-mybatis-是否支持延迟加载-延迟加载的原理是什么" aria-hidden="true">#</a> 117. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h6><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><h6 id="_118-说一下-mybatis-的一级缓存和二级缓存" tabindex="-1"><a class="header-anchor" href="#_118-说一下-mybatis-的一级缓存和二级缓存" aria-hidden="true">#</a> 118. 说一下 MyBatis 的一级缓存和二级缓存？</h6><ul><li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</li><li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</li></ul><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h6 id="_119-mybatis-有哪些执行器-executor" tabindex="-1"><a class="header-anchor" href="#_119-mybatis-有哪些执行器-executor" aria-hidden="true">#</a> 119. MyBatis 有哪些执行器（Executor）？</h6><p>MyBatis 有三种基本的Executor执行器：</p><ul><li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li><li>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li><li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li></ul><h6 id="_120-mybatis-分页插件的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#_120-mybatis-分页插件的实现原理是什么" aria-hidden="true">#</a> 120. MyBatis 分页插件的实现原理是什么？</h6><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h2><h6 id="_121-rabbitmq-的使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#_121-rabbitmq-的使用场景有哪些" aria-hidden="true">#</a> 121. RabbitMQ 的使用场景有哪些？</h6><ul><li>抢购活动，削峰填谷，防止系统崩塌。</li><li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li><li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li></ul><h6 id="_122-rabbitmq-有哪些重要的角色" tabindex="-1"><a class="header-anchor" href="#_122-rabbitmq-有哪些重要的角色" aria-hidden="true">#</a> 122. RabbitMQ 有哪些重要的角色？</h6><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h6 id="_123-rabbitmq-有哪些重要的组件" tabindex="-1"><a class="header-anchor" href="#_123-rabbitmq-有哪些重要的组件" aria-hidden="true">#</a> 123. RabbitMQ 有哪些重要的组件？</h6><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h6 id="_124-rabbitmq-中-vhost-的作用是什么" tabindex="-1"><a class="header-anchor" href="#_124-rabbitmq-中-vhost-的作用是什么" aria-hidden="true">#</a> 124. RabbitMQ 中 vhost 的作用是什么？</h6><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h6 id="_125-rabbitmq-的消息是怎么发送的" tabindex="-1"><a class="header-anchor" href="#_125-rabbitmq-的消息是怎么发送的" aria-hidden="true">#</a> 125. RabbitMQ 的消息是怎么发送的？</h6><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h6 id="_126-rabbitmq-怎么保证消息的稳定性" tabindex="-1"><a class="header-anchor" href="#_126-rabbitmq-怎么保证消息的稳定性" aria-hidden="true">#</a> 126. RabbitMQ 怎么保证消息的稳定性？</h6><ul><li>提供了事务的功能。</li><li>通过将 channel 设置为 confirm（确认）模式。</li></ul><h6 id="_127-rabbitmq-怎么避免消息丢失" tabindex="-1"><a class="header-anchor" href="#_127-rabbitmq-怎么避免消息丢失" aria-hidden="true">#</a> 127. RabbitMQ 怎么避免消息丢失？</h6><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失。</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li></ul><h6 id="_128-要保证消息持久化成功的条件有哪些" tabindex="-1"><a class="header-anchor" href="#_128-要保证消息持久化成功的条件有哪些" aria-hidden="true">#</a> 128. 要保证消息持久化成功的条件有哪些？</h6><ul><li>声明队列必须设置持久化 durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。</li></ul><h6 id="_129-rabbitmq-持久化有什么缺点" tabindex="-1"><a class="header-anchor" href="#_129-rabbitmq-持久化有什么缺点" aria-hidden="true">#</a> 129. RabbitMQ 持久化有什么缺点？</h6><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h6 id="_130-rabbitmq-有几种广播类型" tabindex="-1"><a class="header-anchor" href="#_130-rabbitmq-有几种广播类型" aria-hidden="true">#</a> 130. RabbitMQ 有几种广播类型？</h6><ul><li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li><li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li><li>fanout：分发模式，把消费分发给所有订阅者。</li><li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li></ul><h6 id="_131-rabbitmq-怎么实现延迟消息队列" tabindex="-1"><a class="header-anchor" href="#_131-rabbitmq-怎么实现延迟消息队列" aria-hidden="true">#</a> 131. RabbitMQ 怎么实现延迟消息队列？</h6><p>延迟队列的实现有两种方式：</p><ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li><li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li></ul><h6 id="_132-rabbitmq-集群有什么用" tabindex="-1"><a class="header-anchor" href="#_132-rabbitmq-集群有什么用" aria-hidden="true">#</a> 132. RabbitMQ 集群有什么用？</h6><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ul><h6 id="_133-rabbitmq-节点的类型有哪些" tabindex="-1"><a class="header-anchor" href="#_133-rabbitmq-节点的类型有哪些" aria-hidden="true">#</a> 133. RabbitMQ 节点的类型有哪些？</h6><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h6 id="_134-rabbitmq-集群搭建需要注意哪些问题" tabindex="-1"><a class="header-anchor" href="#_134-rabbitmq-集群搭建需要注意哪些问题" aria-hidden="true">#</a> 134. RabbitMQ 集群搭建需要注意哪些问题？</h6><ul><li>各节点之间使用“--link”连接，此属性不能忽略。</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul><h6 id="_135-rabbitmq-每个节点是其他节点的完整拷贝吗-为什么" tabindex="-1"><a class="header-anchor" href="#_135-rabbitmq-每个节点是其他节点的完整拷贝吗-为什么" aria-hidden="true">#</a> 135. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h6><p>不是，原因有以下两个：</p><ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ul><h6 id="_136-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况" tabindex="-1"><a class="header-anchor" href="#_136-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况" aria-hidden="true">#</a> 136. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h6><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p><h6 id="_137-rabbitmq-对集群节点停止顺序有要求吗" tabindex="-1"><a class="header-anchor" href="#_137-rabbitmq-对集群节点停止顺序有要求吗" aria-hidden="true">#</a> 137. RabbitMQ 对集群节点停止顺序有要求吗？</h6><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p><h2 id="kafka" tabindex="-1"><a class="header-anchor" href="#kafka" aria-hidden="true">#</a> Kafka</h2><h6 id="_138-kafka-可以脱离-zookeeper-单独使用吗-为什么" tabindex="-1"><a class="header-anchor" href="#_138-kafka-可以脱离-zookeeper-单独使用吗-为什么" aria-hidden="true">#</a> 138. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h6><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h6 id="_139-kafka-有几种数据保留的策略" tabindex="-1"><a class="header-anchor" href="#_139-kafka-有几种数据保留的策略" aria-hidden="true">#</a> 139. kafka 有几种数据保留的策略？</h6><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h6 id="_140-kafka-同时设置了-7-天和-10g-清除数据-到第五天的时候消息达到了-10g-这个时候-kafka-将如何处理" tabindex="-1"><a class="header-anchor" href="#_140-kafka-同时设置了-7-天和-10g-清除数据-到第五天的时候消息达到了-10g-这个时候-kafka-将如何处理" aria-hidden="true">#</a> 140. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h6><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h6 id="_141-什么情况会导致-kafka-运行变慢" tabindex="-1"><a class="header-anchor" href="#_141-什么情况会导致-kafka-运行变慢" aria-hidden="true">#</a> 141. 什么情况会导致 kafka 运行变慢？</h6><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h6 id="_142-使用-kafka-集群需要注意什么" tabindex="-1"><a class="header-anchor" href="#_142-使用-kafka-集群需要注意什么" aria-hidden="true">#</a> 142. 使用 kafka 集群需要注意什么？</h6><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li></ul><h2 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> Zookeeper</h2><h6 id="_143-zookeeper-是什么" tabindex="-1"><a class="header-anchor" href="#_143-zookeeper-是什么" aria-hidden="true">#</a> 143. zookeeper 是什么？</h6><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h6 id="_144-zookeeper-都有哪些功能" tabindex="-1"><a class="header-anchor" href="#_144-zookeeper-都有哪些功能" aria-hidden="true">#</a> 144. zookeeper 都有哪些功能？</h6><ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ul><h6 id="_145-zookeeper-有几种部署模式" tabindex="-1"><a class="header-anchor" href="#_145-zookeeper-有几种部署模式" aria-hidden="true">#</a> 145. zookeeper 有几种部署模式？</h6><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul><h6 id="_146-zookeeper-怎么保证主从节点的状态同步" tabindex="-1"><a class="header-anchor" href="#_146-zookeeper-怎么保证主从节点的状态同步" aria-hidden="true">#</a> 146. zookeeper 怎么保证主从节点的状态同步？</h6><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h6 id="_147-集群中为什么要有主节点" tabindex="-1"><a class="header-anchor" href="#_147-集群中为什么要有主节点" aria-hidden="true">#</a> 147. 集群中为什么要有主节点？</h6><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h6 id="_148-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" tabindex="-1"><a class="header-anchor" href="#_148-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" aria-hidden="true">#</a> 148. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h6><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h6 id="_149-说一下-zookeeper-的通知机制" tabindex="-1"><a class="header-anchor" href="#_149-说一下-zookeeper-的通知机制" aria-hidden="true">#</a> 149. 说一下 zookeeper 的通知机制？</h6><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h2><h6 id="_150-数据库的三范式是什么" tabindex="-1"><a class="header-anchor" href="#_150-数据库的三范式是什么" aria-hidden="true">#</a> 150. 数据库的三范式是什么？</h6><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h6 id="_151-一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几" tabindex="-1"><a class="header-anchor" href="#_151-一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几" aria-hidden="true">#</a> 151. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h6><p>表类型如果是 MyISAM ，那 id 就是 8。 表类型如果是 InnoDB，那 id 就是 6。 InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h6 id="_152-如何获取当前数据库版本" tabindex="-1"><a class="header-anchor" href="#_152-如何获取当前数据库版本" aria-hidden="true">#</a> 152. 如何获取当前数据库版本？</h6><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h6 id="_153-说一下-acid-是什么" tabindex="-1"><a class="header-anchor" href="#_153-说一下-acid-是什么" aria-hidden="true">#</a> 153. 说一下 ACID 是什么？</h6><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h6 id="_154-char-和-varchar-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_154-char-和-varchar-的区别是什么" aria-hidden="true">#</a> 154. char 和 varchar 的区别是什么？</h6><ul><li><p>「char(n)」 ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。 chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p></li><li><p>「varchar(n)」 ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p></li></ul><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h6 id="_155-float-和-double-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_155-float-和-double-的区别是什么" aria-hidden="true">#</a> 155. float 和 double 的区别是什么？</h6><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul><h6 id="_156-mysql-的内连接、左连接、右连接有什么区别" tabindex="-1"><a class="header-anchor" href="#_156-mysql-的内连接、左连接、右连接有什么区别" aria-hidden="true">#</a> 156. MySQL 的内连接、左连接、右连接有什么区别？</h6><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h6 id="_157-mysql-索引是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_157-mysql-索引是怎么实现的" aria-hidden="true">#</a> 157. MySQL 索引是怎么实现的？</h6><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h6 id="_158-怎么验证-mysql-的索引是否满足需求" tabindex="-1"><a class="header-anchor" href="#_158-怎么验证-mysql-的索引是否满足需求" aria-hidden="true">#</a> 158. 怎么验证 MySQL 的索引是否满足需求？</h6><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type=1。</p><h6 id="_159-说一下数据库的事务隔离" tabindex="-1"><a class="header-anchor" href="#_159-说一下数据库的事务隔离" aria-hidden="true">#</a> 159. 说一下数据库的事务隔离？</h6><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p><div class="language-ini ext-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">transaction-isolation</span> <span class="token punctuation">=</span> <span class="token value attr-value">REPEATABLE-READ</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><ul><li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取。</li><li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到。</li><li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据。</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><h6 id="_160-说一下-mysql-常用的引擎" tabindex="-1"><a class="header-anchor" href="#_160-说一下-mysql-常用的引擎" aria-hidden="true">#</a> 160. 说一下 MySQL 常用的引擎？</h6><ul><li>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li><li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li></ul><h6 id="_161-说一下-mysql-的行锁和表锁" tabindex="-1"><a class="header-anchor" href="#_161-说一下-mysql-的行锁和表锁" aria-hidden="true">#</a> 161. 说一下 MySQL 的行锁和表锁？</h6><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul><h6 id="_162-说一下乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_162-说一下乐观锁和悲观锁" aria-hidden="true">#</a> 162. 说一下乐观锁和悲观锁？</h6><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li></ul><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h6 id="_163-mysql-问题排查都有哪些手段" tabindex="-1"><a class="header-anchor" href="#_163-mysql-问题排查都有哪些手段" aria-hidden="true">#</a> 163. MySQL 问题排查都有哪些手段？</h6><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li>使用 explain 命令查询 SQL 语句执行计划。</li><li>开启慢查询日志，查看慢查询的 SQL。</li></ul><h6 id="_164-如何做-mysql-的性能优化" tabindex="-1"><a class="header-anchor" href="#_164-如何做-mysql-的性能优化" aria-hidden="true">#</a> 164. 如何做 MySQL 的性能优化？</h6><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li>垂直分割分表。</li><li>选择正确的存储引擎。</li></ul><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><h6 id="_165-redis-是什么-都有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#_165-redis-是什么-都有哪些使用场景" aria-hidden="true">#</a> 165. Redis 是什么？都有哪些使用场景？</h6><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p><p>Redis 使用场景：</p><ul><li>记录帖子点赞数、点击数、评论数；</li><li>缓存近期热帖；</li><li>缓存文章详情信息；</li><li>记录用户会话信息。</li></ul><h6 id="_166-redis-有哪些功能" tabindex="-1"><a class="header-anchor" href="#_166-redis-有哪些功能" aria-hidden="true">#</a> 166. Redis 有哪些功能？</h6><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h6 id="_167-redis-为什么是单线程的" tabindex="-1"><a class="header-anchor" href="#_167-redis-为什么是单线程的" aria-hidden="true">#</a> 167. Redis 为什么是单线程的？</h6><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><h6 id="_168-什么是缓存穿透-怎么解决" tabindex="-1"><a class="header-anchor" href="#_168-什么是缓存穿透-怎么解决" aria-hidden="true">#</a> 168. 什么是缓存穿透？怎么解决？</h6><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h6 id="_169-redis-支持的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#_169-redis-支持的数据类型有哪些" aria-hidden="true">#</a> 169. Redis 支持的数据类型有哪些？</h6><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p><h6 id="_170-怎么保证缓存和数据库数据的一致性" tabindex="-1"><a class="header-anchor" href="#_170-怎么保证缓存和数据库数据的一致性" aria-hidden="true">#</a> 170. 怎么保证缓存和数据库数据的一致性？</h6><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h6 id="_171-redis-的持久化有两种方式-或者说有两种策略" tabindex="-1"><a class="header-anchor" href="#_171-redis-的持久化有两种方式-或者说有两种策略" aria-hidden="true">#</a> 171. Redis 的持久化有两种方式，或者说有两种策略：</h6><ul><li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li></ul><h6 id="_172-redis-怎么实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_172-redis-怎么实现分布式锁" aria-hidden="true">#</a> 172. Redis 怎么实现分布式锁？</h6><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h6 id="_173-redis-分布式锁有什么缺陷" tabindex="-1"><a class="header-anchor" href="#_173-redis-分布式锁有什么缺陷" aria-hidden="true">#</a> 173. Redis 分布式锁有什么缺陷？</h6><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h6 id="_174-redis-如何做内存优化" tabindex="-1"><a class="header-anchor" href="#_174-redis-如何做内存优化" aria-hidden="true">#</a> 174. Redis 如何做内存优化？</h6><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h6 id="_175-redis-淘汰策略有哪些" tabindex="-1"><a class="header-anchor" href="#_175-redis-淘汰策略有哪些" aria-hidden="true">#</a> 175. Redis 淘汰策略有哪些？</h6><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。 allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。 allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。 no-enviction（驱逐）：禁止驱逐数据。</p><h6 id="_176-redis-常见的性能问题有哪些-该如何解决" tabindex="-1"><a class="header-anchor" href="#_176-redis-常见的性能问题有哪些-该如何解决" aria-hidden="true">#</a> 176. Redis 常见的性能问题有哪些？该如何解决？</h6><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2><h6 id="_177-说一下-jvm-的主要组成部分-及其作用" tabindex="-1"><a class="header-anchor" href="#_177-说一下-jvm-的主要组成部分-及其作用" aria-hidden="true">#</a> 177. 说一下 JVM 的主要组成部分？及其作用？</h6><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p>「组件的作用：」 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h6 id="_178-说一下-jvm-运行时数据区" tabindex="-1"><a class="header-anchor" href="#_178-说一下-jvm-运行时数据区" aria-hidden="true">#</a> 178. 说一下 JVM 运行时数据区？</h6><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h6 id="_179-说一下堆栈的区别" tabindex="-1"><a class="header-anchor" href="#_179-说一下堆栈的区别" aria-hidden="true">#</a> 179. 说一下堆栈的区别？</h6><ul><li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li><li>共享性：堆是线程共享的，栈是线程私有的。</li><li>空间大小：堆大小远远大于栈。</li></ul><h6 id="_180-队列和栈是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#_180-队列和栈是什么-有什么区别" aria-hidden="true">#</a> 180. 队列和栈是什么？有什么区别？</h6><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h6 id="_181-什么是双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_181-什么是双亲委派模型" aria-hidden="true">#</a> 181. 什么是双亲委派模型？</h6><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=&quot;box-sizing: border-box; outline: 0px !important;&quot;&gt;libext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><h6 id="_182-说一下类装载的执行过程" tabindex="-1"><a class="header-anchor" href="#_182-说一下类装载的执行过程" aria-hidden="true">#</a> 182. 说一下类装载的执行过程？</h6><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h6 id="_183-怎么判断对象是否可以被回收" tabindex="-1"><a class="header-anchor" href="#_183-怎么判断对象是否可以被回收" aria-hidden="true">#</a> 183. 怎么判断对象是否可以被回收？</h6><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h6 id="_184-java-中都有哪些引用类型" tabindex="-1"><a class="header-anchor" href="#_184-java-中都有哪些引用类型" aria-hidden="true">#</a> 184. Java 中都有哪些引用类型？</h6><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h6 id="_185-说一下-jvm-有哪些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_185-说一下-jvm-有哪些垃圾回收算法" aria-hidden="true">#</a> 185. 说一下 JVM 有哪些垃圾回收算法？</h6><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h6 id="_186-说一下-jvm-有哪些垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_186-说一下-jvm-有哪些垃圾回收器" aria-hidden="true">#</a> 186. 说一下 JVM 有哪些垃圾回收器？</h6><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul><h6 id="_187-详细介绍一下-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_187-详细介绍一下-cms-垃圾回收器" aria-hidden="true">#</a> 187. 详细介绍一下 CMS 垃圾回收器？</h6><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h6 id="_188-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_188-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别" aria-hidden="true">#</a> 188. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h6><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h6 id="_189-简述分代垃圾回收器是怎么工作的" tabindex="-1"><a class="header-anchor" href="#_189-简述分代垃圾回收器是怎么工作的" aria-hidden="true">#</a> 189. 简述分代垃圾回收器是怎么工作的？</h6><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h6 id="_190-说一下-jvm-调优的工具" tabindex="-1"><a class="header-anchor" href="#_190-说一下-jvm-调优的工具" aria-hidden="true">#</a> 190. 说一下 JVM 调优的工具？</h6><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h6 id="_191-常用的-jvm-调优的参数都有哪些" tabindex="-1"><a class="header-anchor" href="#_191-常用的-jvm-调优的参数都有哪些" aria-hidden="true">#</a> 191. 常用的 JVM 调优的参数都有哪些？</h6><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul><h2 id="数据结构和算法" tabindex="-1"><a class="header-anchor" href="#数据结构和算法" aria-hidden="true">#</a> 数据结构和算法</h2><h6 id="_192-linkedlist在jdk1-8前后数据结构有什么不同" tabindex="-1"><a class="header-anchor" href="#_192-linkedlist在jdk1-8前后数据结构有什么不同" aria-hidden="true">#</a> 192. LinkedList在JDK1.8前后数据结构有什么不同？</h6><ul><li>在JDK1.8之前，LinkedList的数据结构是双向循环链表（头尾相接）；</li><li>从JDK1.8开始，LinkedList的数据结构为双向链表。</li></ul><p>双向循环链表的查找过程与双向链表相同，均为：</p><ul><li>判断查找元素与链表长度一般的关系： <ul><li>小于，则从header开始顺序查找</li><li>否则，则从header开始逆序查找</li></ul></li></ul><h6 id="_193-arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_193-arraylist和linkedlist的区别" aria-hidden="true">#</a> 193. ArrayList和LinkedList的区别？</h6><p>ArrayList查询性能更高，LinkedList进行头尾增删性能更高，除此以外，其他增删，ArrayList和LinkedList差不多。</p><h6 id="_194-sof和oom是什么" tabindex="-1"><a class="header-anchor" href="#_194-sof和oom是什么" aria-hidden="true">#</a> 194. SOF和OOM是什么？</h6><ul><li>SOF：statckOverFlowError -- 栈内存溢出</li><li>OOM：OutOfMemoryError -- 堆内存溢出</li></ul><h6 id="_195-内存泄漏和内存溢出的区别" tabindex="-1"><a class="header-anchor" href="#_195-内存泄漏和内存溢出的区别" aria-hidden="true">#</a> 195. 内存泄漏和内存溢出的区别？</h6><ul><li>内存溢出：剩余内存不足以分配给请求的资源，此时会出现内存溢出。</li><li>内存泄漏：分配出去的内存回收不回来，此时这个现象就叫做内存泄漏。</li></ul><p>两者关系：内存泄漏积累到一定程度才会造成内存溢出，并不是内存泄漏一但出现，则立即出现内存溢出，出现内存溢出并不一定是由于内存泄漏造成的，还可能是因为创建了大对象造成的。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: abel.liu@outlook.co.nz">Abel Liu</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.85e154b6.js" defer></script>
  </body>
</html>
